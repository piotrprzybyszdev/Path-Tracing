#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

#include "ShaderRendererTypes.incl"
#include "DebugShaderRendererTypes.incl"
#include "DebugShaderTypes.incl"

layout(constant_id = DebugRenderModeConstantId) const uint s_RenderMode = RenderModeColor;
layout(constant_id = DebugRaygenFlagsConstantId) const uint s_RaygenFlags = RaygenFlagsNone;

layout(binding = 0, set = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D u_Image;
layout(binding = 2, set = 0) uniform MainBlock {
    RaygenUniformData mainUniform;
};

layout(location = 0) rayPayloadEXT DebugPayload payload;

#include "ray.glsl"

void main()
{
    Ray rx, ry;
    const Ray ray = constructPrimaryRay(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.MainCamera, rx, ry);
    payload.RxDirection = rx.Direction;
    payload.RyDirection = ry.Direction;

    uint flags = gl_RayFlagsNoneEXT;
    if ((s_RaygenFlags & RaygenFlagsForceOpaque) != RaygenFlagsNone)
        flags |= gl_RayFlagsOpaqueEXT;
    if ((s_RaygenFlags & RaygenFlagsCullBackFaces) != RaygenFlagsNone)
        flags |= gl_RayFlagsCullBackFacingTrianglesEXT;

    traceRayEXT(u_TopLevelAS, flags, 0xff, PrimaryRayHitGroupIndex, 2, PrimaryRayMissGroupIndex, ray.Origin, ray.tmin, ray.Direction, ray.tmax, 0);
  
    imageStore(u_Image, ivec2(gl_LaunchIDEXT.xy), vec4(payload.hitValue, 1.0f));
}
