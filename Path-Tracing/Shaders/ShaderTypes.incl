#ifndef GL_core_profile
#pragma once

#include <glm/glm.hpp>

namespace PathTracing::Shaders
{

using namespace glm;

using SpecializationConstant    = uint;
using MaterialId                = uint;

#endif

const uint MaxUniformBufferSize                     = 64 * 1024u;

const uint DefaultColorTextureIndex                 = 0;
const uint DefaultNormalTextureIndex                = 1;
const uint DefaultRoughnessTextureIndex             = 2;
const uint DefaultMetallicTextureIndex               = 3;
const uint DefaultEmissiveTextureIndex              = 4;
const uint PlaceholderTextureIndex                  = 5;
const uint SceneTextureOffset                       = 6;

const uint MaxTextureCount                          = 1024u;
const uint MaxLightCount                            = 64u;
const uint MaxBonesPerVertex                        = 4u;
const uint MaxBones                                 = MaxUniformBufferSize / (3 * 4 * 4);
const uint MaxMaterialCount                         = 1 << 24;

struct Camera
{
    mat4 ViewInverse;
    mat4 ProjInverse;
};

struct Vertex
{
    vec3 Position;
    vec2 TexCoords;
    vec3 Normal;
    vec3 Tangent;
    vec3 Bitangent;
};

struct AnimatedVertex
{
    vec3 Position;
    vec2 TexCoords;
    vec3 Normal;
    vec3 Tangent;
    vec3 Bitangent;
    uint BoneIndices[MaxBonesPerVertex];
    float BoneWeights[MaxBonesPerVertex];
};

struct MetallicRoughnessMaterial
{
    vec3 EmissiveColor;
    float EmissiveIntensity;
    vec4 Color;
    float Roughness;
    float Metalness;
    float Ior;
    float Transmission;
    float pad0;
    float pad1;
    float pad2;
    uint EmissiveIdx;
    uint ColorIdx;
    uint NormalIdx;
    uint RoughnessIdx;
    uint MetallicIdx;
};

struct SpecularGlossinessMaterial
{
    vec3 EmissiveColor;
    float EmissiveIntensity;
    uint EmissiveIdx;
    uint DiffuseIdx;
    uint NormalIdx;
    uint GlossSpecularIdx;
};

struct DirectionalLight
{
    vec3 Color;
    float pad0;
    vec3 Direction;
    float pad1;
};

struct PointLight
{
    vec3 Color;
    float pad0;
    vec3 Position;
    float pad1;
    float AttenuationConstant;
    float AttenuationLinear;
    float AttenuationQuadratic;
    float pad2;
};

const uint DirectionalLightStructAlignment  = 16u;
const uint PointLightStructAlignment        = 16u;

const uint MaterialTypeMetallicRoughness     = 0u;
const uint MaterialTypeSpecularGlossiness   = 1u;


#ifndef GL_core_profile

inline uint GetSceneTextureIndex(uint textureIndex)
{
    return SceneTextureOffset + textureIndex;
}

inline uint CreateMaterialId(uint materialIndex, uint materialType)
{
    return (materialIndex << 8) | materialType;
}

}

#else

uint unpackMaterialId(uint materialId, out uint materialType)
{
    materialType = materialId & 0x000000ffu;
    return materialId >> 8;
}

#endif
