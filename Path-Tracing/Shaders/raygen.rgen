#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

#include "ShaderRendererTypes.incl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D u_Image;
layout(binding = 2, set = 0) uniform MainBlock {
    RaygenUniformData mainUniform;
};

layout(binding = 3, set = 0) uniform sampler2D textures[];

layout(binding = 8, set = 0) uniform LightsBuffer {
    uint u_LightCount;
    DirectionalLight u_DirectionalLight;
    PointLight[MaxLightCount] u_Lights;
};

layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT bool isOccluded;

#include "ray.glsl"
#include "shading.glsl"
#include "tracing.glsl"

bool sampleLight(out vec3 lightDirection, out vec3 lightColor, out float lightDistance, out float attenuation, vec3 position, inout uint rngState)
{
    uint lightIndex = uint(rand(rngState) * (u_LightCount + 1));
    
    if (lightIndex >= u_LightCount)
    {
        lightDirection = u_DirectionalLight.Direction;
        lightColor = u_DirectionalLight.Color;
        lightDistance = DirectionalLightDistance;
        attenuation = 1.0f;
        return true;
    }

    const PointLight light = u_Lights[lightIndex];

    // Area-light sampling: sample a point on a small sphere around the original point light position.
    // You can tune this radius to control apparent size of the area light.
    const float AreaLightRadius = 0.01f;

    // Sample direction on unit sphere (getRandomUnitSphere is defined in common.glsl)
    vec3 sphereDir = getRandomUnitSphere(rngState);

    vec3 sampledPosition = light.Position + sphereDir * AreaLightRadius;

    lightDistance = distance(position, sampledPosition);
    lightDirection = normalize(position - sampledPosition);
    lightColor = light.Color;

    // Attenuation computed using the sampled distance from the surface point to the sampled light position.
    attenuation = 1.0f / (light.AttenuationConstant + lightDistance * light.AttenuationLinear + lightDistance * lightDistance * light.AttenuationQuadratic);
    attenuation = clamp(attenuation, 0.0f, 1.0f);

    return false;
}

void main()
{
    uint rngState = initRng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.TotalSamples);

    vec2 u = vec2(rand(rngState), rand(rngState));
    const Ray primaryRay = constructPrimaryRay(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.MainCamera, u);

    vec3 radiance = vec3(0.0f);

    for (int smpl = 0; smpl < mainUniform.SampleCount; smpl++)
    {
        vec3 throughput = vec3(1.0f);
        Ray ray = primaryRay;

        for (int bounce = 0; bounce < mainUniform.BounceCount; bounce++)
        {
            payload.RngState = rngState;
            traceRayEXT(u_TopLevelAS, gl_RayFlagsNoneEXT, 0xff, PrimaryRayHitGroupIndex, 2, PrimaryRayMissGroupIndex, ray.Origin, ray.tmin, ray.Direction, ray.tmax, 0);
            rngState = payload.RngState;

            if (payload.Distance == MISS_HIT_DISTANCE)
            {
                // radiance += throughput * payload.Position;
                break;
            }
            
            // sampleLight(lightDirection, lightColor, lightDistance, attenuation, payload.Position, rngState);

            radiance += throughput * payload.Emissive;

		    throughput *= payload.Bsdf / max(payload.Pdf, 0.001f);

            const float prob = max(throughput.r, max(throughput.g, throughput.b));
            if (prob < 0.001f)
                break;

            if (prob < rand(rngState))
                break;

            throughput /= prob;

            const vec3 hitPosition = ray.Origin + ray.Direction * payload.Distance;
            ray.Origin = hitPosition + payload.Direction * 0.001f;
            ray.Direction = payload.Direction;
        }
    }
    
    vec3 prevColor = imageLoad(u_Image, ivec2(gl_LaunchIDEXT.xy)).rgb;
    radiance = (radiance * mainUniform.Exposure + prevColor * mainUniform.TotalSamples) / (mainUniform.TotalSamples + mainUniform.SampleCount);

    imageStore(u_Image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.0f));
}
