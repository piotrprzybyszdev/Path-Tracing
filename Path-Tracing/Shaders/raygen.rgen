#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

#include "ShaderRendererTypes.incl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D u_Image;
layout(binding = 2, set = 0) uniform MainBlock {
    RaygenUniformData mainUniform;
};

layout(binding = 3, set = 0) uniform sampler2D textures[];

layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT bool isOccluded;

#include "ray.glsl"
#include "shading.glsl"
#include "tracing.glsl"

void main()
{
    uint rngState = initRng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.TotalSamples);

    vec3 radiance = vec3(0.0f);

    for (int smpl = 0; smpl < mainUniform.SampleCount; smpl++)
    {
        vec3 throughput = vec3(1.0f);

        vec2 u = vec2(rand(rngState), rand(rngState));
        Ray rx, ry;
        Ray ray = constructPrimaryRay(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.MainCamera, u, rx, ry);
        payload.RxOrigin = rx.Origin;
        payload.RxDirection = rx.Direction;
        payload.RyOrigin = ry.Origin;
        payload.RyDirection = ry.Direction;

        payload.MaxRoughness = 0.0f;
        
        for (int bounce = 0; bounce < mainUniform.BounceCount; bounce++)
        {
            payload.RngState = rngState;
            traceRayEXT(u_TopLevelAS, gl_RayFlagsNoneEXT, 0xff, PrimaryRayHitGroupIndex, 2, PrimaryRayMissGroupIndex, ray.Origin, ray.tmin, ray.Direction, ray.tmax, 0);
            rngState = payload.RngState;

            if (payload.Pdf == -1.0f)
            {
                radiance += throughput * payload.Emissive;
                break;
            }

            radiance += throughput * payload.Emissive;
            
            if (payload.DirectLightPdf > 0.0f)
                if (!checkOccluded(payload.LightDirection, payload.Position, payload.LightDistance))
                    radiance += throughput * payload.DirectLight / payload.DirectLightPdf;
             
            if (payload.Pdf > 0.0f)
                throughput *= payload.Bsdf / payload.Pdf;
            
            const float prob = min(maxComponent(throughput), 1.0f);
            if (prob < 0.001f)
                break;

            if (prob < rand(rngState))
                break;

            throughput /= prob;

            ray.Origin = payload.Position;
            ray.Direction = payload.Direction;
        }
    }
    
    const ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
    const vec3 prevColor = imageLoad(u_Image, imageCoords).rgb;
    imageStore(u_Image, imageCoords, vec4(radiance + prevColor, 1.0f));
}
