#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require

#include "ShaderRendererTypes.incl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D u_Image;
layout(binding = 2, set = 0) uniform MainBlock {
    RaygenUniformData mainUniform;
};

layout(binding = 3, set = 0) uniform sampler2D textures[];

layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT bool isOccluded;

#include "ray.glsl"
#include "shading.glsl"
#include "tracing.glsl"

void main()
{
    uint rngState = initRng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.TotalSamples);

    vec2 u = vec2(rand(rngState), rand(rngState));
    const Ray primaryRay = constructPrimaryRay(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, mainUniform.MainCamera, u);

    vec3 radiance = vec3(0.0f);

    for (int smpl = 0; smpl < mainUniform.SampleCount; smpl++)
    {
        vec3 throughput = vec3(1.0f);
        Ray ray = primaryRay;

        for (int bounce = 0; bounce < mainUniform.BounceCount; bounce++)
        {
            payload.RngState = rngState;
            traceRayEXT(u_TopLevelAS, gl_RayFlagsNoneEXT, 0xff, PrimaryRayHitGroupIndex, 2, PrimaryRayMissGroupIndex, ray.Origin, ray.tmin, ray.Direction, ray.tmax, 0);
            rngState = payload.RngState;

            if (payload.Pdf == -1.0f)
            {
                if (bounce == 0)
                    radiance += throughput * payload.Emissive;
                break;
            }

            radiance += throughput * payload.Emissive;

            if (!checkOccluded(payload.LightDirection, payload.Position, payload.LightDistance))
                radiance += throughput * payload.DirectLight / max(payload.DirectLightPdf, 0.0001f);
            
            throughput *= payload.Bsdf / max(payload.Pdf, 0.0001f);
            
            const float prob = min(max(throughput.r, max(throughput.g, throughput.b)), 1.0f);
            if (prob < 0.001f)
                break;

            if (prob < rand(rngState))
                break;

            throughput /= prob;

            ray.Origin = payload.Position;
            ray.Direction = payload.Direction;
        }
    }
    
    vec3 prevColor = imageLoad(u_Image, ivec2(gl_LaunchIDEXT.xy)).rgb;
    radiance = (radiance * mainUniform.Exposure + prevColor * mainUniform.TotalSamples) / (mainUniform.TotalSamples + mainUniform.SampleCount);
       
    if (isnan(radiance.r) || isnan(radiance.g) || isnan(radiance.b))
        radiance = vec3(5000.0f, 0.0f, 0.0f);
    if (prevColor == vec3(5000.0f, 0.0f, 0.0f))
        radiance = vec3(5000.0f, 0.0f, 0.0f);

    imageStore(u_Image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.0f));
}
